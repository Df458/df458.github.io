<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel='stylesheet' href='../theme.css'>
        <link rel='stylesheet' href='../main.css'>
        <link rel='stylesheet' href='../tutorials.css'>
        <link rel='stylesheet' href='../highlight.css'>
        <link rel='icon' href='../icon.png' sizes="192x192">
        <meta name="theme-color" content="#202020">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <script src="popup_close.js"></script>
    <title>Hugues Ross - Tutorials</title>
    </head>
    <body>
    <header>
        <a id="main-name" href="../index.html">Hugues Ross</a>
        <div class="main-nav">
            <a class="nav-entry" href="../about.html">About</a>
            <a class="nav-entry" href="http://www.huguesross.net">Blog</a>
            <a class="nav-entry selected" href="../tutorials.html">Tutorials</a>
            <a class="nav-entry" href="../software.html">Software</a>
            <a class="nav-entry" href="../games.html">Games</a>
        </div>
    </header>
    <!-- Main Area -->
    <main role="main">
        <div class="tnav-flex">
            <a href="roguelike_03.html" rel="prev"><img class="txt-icon" src="../img/prev.svg">Previous</a>
            <a href="roguelike_index.html">Index</a>
            <a href="roguelike_05.html" rel="next">Next<img class="txt-icon" src="../img/next.svg"></a>
        </div>
        <h1>Let's Make a Roguelike - 4 - Basic Generation: Natural Spaces</h1>
        <p>
            Last time, we created an empty map for the player to walk around in.
            This time, we'll be turning that empty rectangle into a cavelike area.
        </p>
        <h2>Followup</h2>
        <h3>Fixing the Cursor</h3>
        <p>
            Since this was the first real followup problem, I decided to keep it simple.
            When we draw the player with mvaddch, we move the cursor to the player's position then draw their character in that space.
            When that happens, the cursor advances by one to the right, leaving it next to the player that we drew.
            To resolve this, we can simply call <b>move()</b> again:
        </p>
<pre class="hl">
<span class="hl lin">   18 </span>        <span class="hl kwd">actor_draw</span><span class="hl opt">(</span>actor<span class="hl opt">);</span>
<span class="hl lin">   19 </span>        <span class="hl kwd">move</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>              <span class="hl slc">// Place the cursor at a specified location</span>
<span class="hl lin">   20 </span>        <span class="hl kwd">move</span><span class="hl opt">(</span>actor<span class="hl opt">-&gt;</span>y<span class="hl opt">,</span> actor<span class="hl opt">-&gt;</span>x<span class="hl opt">);</span> <span class="hl slc">// ...Or place the cursor on the player</span>
</pre>
        <h3>A Camera</h3>
        <p>
            If you've never made any sort of moving viewport, it can seem like a daunting task.
            Thankfully, making a camera is easier than it seems at first.
            As I hinted at last time, the trick to creating a camera is moving the world to match the player's location, rather than moving some invisible &quot;thing&quot; to the player.
            For my implementation, I stuck with the assumption that an actor (such as the player) is always the center of attention:
        </p>
<pre class="hl">
<span class="hl lin">  141 </span><span class="hl kwb">void</span> <span class="hl kwd">map_draw</span><span class="hl opt">(</span>map<span class="hl opt">*</span> m<span class="hl opt">,</span> actor<span class="hl opt">*</span> focus<span class="hl opt">) {</span>
<span class="hl lin">  142 </span>    <span class="hl slc">// Get the offset needed to put the focus in the center of the view</span>
<span class="hl lin">  143 </span>    <span class="hl kwb">int</span> offset_y <span class="hl opt">=</span> focus<span class="hl opt">-&gt;</span>y <span class="hl opt">- (</span>VIEW_LINES <span class="hl opt">/</span> <span class="hl num">2</span><span class="hl opt">);</span>
<span class="hl lin">  144 </span>    <span class="hl kwb">int</span> offset_x <span class="hl opt">=</span> focus<span class="hl opt">-&gt;</span>x <span class="hl opt">- (</span>VIEW_COLS <span class="hl opt">/</span> <span class="hl num">2</span><span class="hl opt">);</span>
<span class="hl lin">  145 </span>
<span class="hl lin">  146 </span>    <span class="hl slc">// Adjust the offset so that small maps are centered</span>
<span class="hl lin">  147 </span>    <span class="hl kwa">if</span><span class="hl opt">(</span>m<span class="hl opt">-&gt;</span>lines <span class="hl opt">&lt;=</span> VIEW_LINES<span class="hl opt">) {</span>
<span class="hl lin">  148 </span>        offset_y <span class="hl opt">= -(</span>VIEW_LINES <span class="hl opt">-</span> m<span class="hl opt">-&gt;</span>lines<span class="hl opt">) /</span> <span class="hl num">2</span><span class="hl opt">;</span>
<span class="hl lin">  149 </span>    <span class="hl opt">}</span>
<span class="hl lin">  150 </span>    <span class="hl kwa">if</span><span class="hl opt">(</span>m<span class="hl opt">-&gt;</span>columns <span class="hl opt">&lt;=</span> VIEW_COLS<span class="hl opt">) {</span>
<span class="hl lin">  151 </span>        offset_x <span class="hl opt">= -(</span>VIEW_COLS <span class="hl opt">-</span> m<span class="hl opt">-&gt;</span>columns<span class="hl opt">) /</span> <span class="hl num">2</span><span class="hl opt">;</span>
<span class="hl lin">  152 </span>    <span class="hl opt">}</span>
<span class="hl lin">  153 </span>    
<span class="hl lin">  154 </span>    <span class="hl slc">// Draw with the calculated offset</span>
<span class="hl lin">  155 </span>    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">= (</span>offset_y <span class="hl opt">&gt;</span> <span class="hl num">0</span> <span class="hl opt">?</span> offset_y <span class="hl opt">:</span> <span class="hl num">0</span><span class="hl opt">);</span> i <span class="hl opt">&lt; (</span>offset_y <span class="hl opt">+</span> VIEW_LINES <span class="hl opt">&lt;=</span> m<span class="hl opt">-&gt;</span>lines <span class="hl opt">?</span> offset_y <span class="hl opt">+</span> VIEW_LINES <span class="hl opt">:</span> m<span class="hl opt">-&gt;</span>lines<span class="hl opt">); ++</span>i<span class="hl opt">) {</span>
<span class="hl lin">  156 </span>        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">= (</span>offset_x <span class="hl opt">&gt;</span> <span class="hl num">0</span> <span class="hl opt">?</span> offset_x <span class="hl opt">:</span> <span class="hl num">0</span><span class="hl opt">);</span> j <span class="hl opt">&lt; (</span>offset_x <span class="hl opt">+</span> VIEW_COLS <span class="hl opt">&lt;=</span> m<span class="hl opt">-&gt;</span>columns <span class="hl opt">?</span> offset_x <span class="hl opt">+</span> VIEW_COLS <span class="hl opt">:</span> m<span class="hl opt">-&gt;</span>columns<span class="hl opt">); ++</span>j<span class="hl opt">) {</span>
<span class="hl lin">  157 </span>            <span class="hl kwd">mvaddch</span><span class="hl opt">(</span>i <span class="hl opt">-</span> offset_y<span class="hl opt">,</span> j <span class="hl opt">-</span> offset_x<span class="hl opt">,</span> m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>character<span class="hl opt">);</span>
<span class="hl lin">  158 </span>        <span class="hl opt">}</span>
<span class="hl lin">  159 </span>    <span class="hl opt">}</span>
<span class="hl lin">  160 </span><span class="hl opt">}</span>
</pre>
        <p>
            One thing to note about the code above is that it locks the map to the center if it's smaller than the viewport.
            This makes for a very nice camera that plays well with both big and small maps.
            In addition to the map, the actors must also be offset by the camera in the same manner as shown above.
        </p>
        <h2>Adding Walls</h2>
        <p>
            If we want levels that aren't just empty spaces, we'll need to add solid tiles.
            Depending on your game, there could be many different types of 'solid' tiles: water, pits, walls, doors, and more.
            For now, we'll just add a bool to our tile struct to decide whether or not an actor can move there.
        </p>
        <aside class="note">
            <h4 class="note-heading">Note - Dealing with bools</h4>
            The bool type isn't available in C by default.
            Normally, we could get it by including the stdbool.h header.
            However, curses already defines the type for us to use as we like!
        </aside>

        <h2>Designing a Random Level</h2>
        <p>
            At this point, we can (theoretically) create a non-blank level.
            That means it's time to procedurally generate our first random level!
            As the title of this part implies, we'll be looking at a couple simple-but-effective ways of making cave-like maps.
            Before we start, though, let's consider design.
        </p>
        <p>
            When designing a level for your roguelike, it's important to know what the world you're building should be like.
            To date, I've made 3 roguelikes for past 7DRL entries, and each one of them uses different algorithms to make their worlds.
        </p>

        <h3>Something Something Office Rampage</h3>
        <p>
            Something Something Office Rampage takes place in an office building with a secret underground laboratory.
            The upper floors, being an office, were simple collections of boxy rooms and corridors.
            I was very inexperienced when I made the game, so these levels aren't very well put-together.
            Below these floors is the lobby, a wide-open floor.
            This is followed up by sewers and the aforementioned laboratory.
            Both of these sets of floors use a simple maze-building algorithm to give them a twisting, confusing feel.
            The two sets are still different, however. The sewers are a normal labyrinth, but for the labs I scaled the maze up and made each &quot;space&quot; a 3x3 room.
        </p>
        <p>
            Contrasting these last two floor sets is particularly important, because even using the same algorithm I was able to make two relatively different levels with only small tweaks.
            As you start building algorithms for making levels, you'll find that even playing with details can often create large differences.
        </p>

        <h3>To the West</h3>
        <p>
            To the West is a game about travelling... to the west.
            This means that I needed to create a number of biomes that the player would pass through on their journey.
            To achieve this, I created a simple XML-based format for creating biomes.
        </p>
        <p>
            The actual generation algorithm is quite simple. 
            The developer specifies a range of sizes and a relative difficulty (distance) for the biome.
            Then, they specify the tiles and their rarity.
            The rest is handled by simple calls to <b>rand()</b>.
        </p>

        <h3>Growgue</h3>
        <p>
            Due to a lack of time and motivation, Growgue's levels were pretty boring.
            Since I was making a game that was (mostly) in a cave, I just used the drunkard's walk (which I explain below) to make the levels.
        </p>
        <br />
        <p>
            As you can see, the setting and feel of a game are very important to consider when preparing the game's level generators.
            Throughout this series, I'll be trying to showcase different tricks and algorithms, but at the end of the day it's up to you to determine what your game needs.
        </p>

        <h2>The Drunkard's Walk</h2>
        <p>
            Let's start with the first, and arguably the simplest, algorithm at our disposal: The Drunkard's Walk.
            This simple algorithm can be described as:
        </p>
        <i>Step in a random direction.<br/>Make the space that you're on non-solid.<br/>Repeat until a quota has been reached.</i>
        <p>
            The result is a messy, organic-looking map:
        </p>
        <img class="center-screenshot" src="roguelike_04_01.png" alt="A screenshot displaying the results of a drunkard's walk: Organic zigzagging corridors connecting occasional larger open areas"/>
        <p>
            Here's the code I used to create the level above:
        </p>
<pre class="hl">
<span class="hl lin">   20 </span><span class="hl kwb">void</span> <span class="hl kwd">map_generate_drunkards</span><span class="hl opt">(</span>map<span class="hl opt">*</span> m<span class="hl opt">,</span> actor<span class="hl opt">*</span> a<span class="hl opt">) {</span>
<span class="hl lin">   21 </span>    <span class="hl kwb">uint16_t</span> y <span class="hl opt">=</span> a<span class="hl opt">-&gt;</span>y<span class="hl opt">;</span> <span class="hl slc">// We want to start at the player&apos;s location,</span>
<span class="hl lin">   22 </span>    <span class="hl kwb">uint16_t</span> x <span class="hl opt">=</span> a<span class="hl opt">-&gt;</span>x<span class="hl opt">;</span> <span class="hl slc">// in order to guarantee that they spawn in the map.</span>
<span class="hl lin">   23 </span>    <span class="hl kwb">uint16_t</span> count <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl lin">   24 </span>
<span class="hl lin">   25 </span>    <span class="hl slc">// You can change the number that we multiply to adjust how much open space</span>
<span class="hl lin">   26 </span>    <span class="hl slc">// the map has.</span>
<span class="hl lin">   27 </span>    <span class="hl kwa">while</span><span class="hl opt">(</span>count <span class="hl opt">&lt;</span> m<span class="hl opt">-&gt;</span>lines <span class="hl opt">*</span> m<span class="hl opt">-&gt;</span>columns <span class="hl opt">*</span> <span class="hl num">0.2</span><span class="hl opt">) {</span>
<span class="hl lin">   28 </span>        <span class="hl kwa">if</span><span class="hl opt">(</span>m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">].</span>solid<span class="hl opt">) {</span>
<span class="hl lin">   29 </span>            m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">].</span>solid <span class="hl opt">=</span> FALSE<span class="hl opt">;</span>
<span class="hl lin">   30 </span>            m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">].</span>character <span class="hl opt">=</span> <span class="hl str">&apos;.&apos;</span><span class="hl opt">;</span>
<span class="hl lin">   31 </span>
<span class="hl lin">   32 </span>            count<span class="hl opt">++;</span>
<span class="hl lin">   33 </span>        <span class="hl opt">}</span>
<span class="hl lin">   34 </span>
<span class="hl lin">   35 </span>        <span class="hl slc">// Move in a random direction, avoiding the edges</span>
<span class="hl lin">   36 </span>        <span class="hl kwa">if</span><span class="hl opt">(!(</span><span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">2</span><span class="hl opt">)) {</span>
<span class="hl lin">   37 </span>            <span class="hl kwa">if</span><span class="hl opt">(</span>y <span class="hl opt">&gt;</span> <span class="hl num">1</span> <span class="hl opt">&amp;&amp; (!(</span><span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">2</span><span class="hl opt">) ||</span> y <span class="hl opt">+</span> <span class="hl num">1</span> <span class="hl opt">&gt;=</span> m<span class="hl opt">-&gt;</span>lines <span class="hl opt">-</span> <span class="hl num">2</span><span class="hl opt">))</span>
<span class="hl lin">   38 </span>                y<span class="hl opt">--;</span>
<span class="hl lin">   39 </span>            <span class="hl kwa">else</span>
<span class="hl lin">   40 </span>                y<span class="hl opt">++;</span>
<span class="hl lin">   41 </span>        <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span>
<span class="hl lin">   42 </span>            <span class="hl kwa">if</span><span class="hl opt">(</span>x <span class="hl opt">&gt;</span> <span class="hl num">1</span> <span class="hl opt">&amp;&amp; (!(</span><span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">2</span><span class="hl opt">) ||</span> x <span class="hl opt">+</span> <span class="hl num">1</span> <span class="hl opt">&gt;=</span> m<span class="hl opt">-&gt;</span>columns <span class="hl opt">-</span> <span class="hl num">2</span><span class="hl opt">))</span>
<span class="hl lin">   43 </span>                x<span class="hl opt">--;</span>
<span class="hl lin">   44 </span>            <span class="hl kwa">else</span>
<span class="hl lin">   45 </span>                x<span class="hl opt">++;</span>
<span class="hl lin">   46 </span>        <span class="hl opt">}</span>
<span class="hl lin">   47 </span>    <span class="hl opt">}</span>
<span class="hl lin">   48 </span><span class="hl opt">}</span>
</pre>
        <h3>Benefits</h3>
        <ul>
            <li>Very simple to understand and implement.</li>
            <li>Cursor-based nature makes this algorithm easy to visualize in real-time.</li>
            <li>All open spaces are guaranteed to be connected.</li>
            <li>Allows you to precisely control the size of your level.</li>
        </ul>

        <h3>Drawbacks</h3>
        <ul>
            <li>Takes an unknown (usually pretty slow) length of time, which is determined by random numbers! This can be combatted by putting a hard limit on cycles, but you will no longer know the level size for certain.</li>
            <li>Results can vary wildly. This is not necessarily a drawback, but it's important to acknowledge.</li>
            <li>Tends to create flat edges along map borders. This can be fixed by making the map auto-resize, but this can slow down the generation speed.</li>
        </ul>

        <h2>Erosion</h2>
        <p>
            Next, here's another method of making caves.
            This one is much more complex, but can create some nice caverns and works with other algorithms as well.
            Rather than moving a cursor, we can generate caves using <i>cellular automata</i>.
            For the uninitiated, cellular automata are a fairly interesting branch of computation.
            For our purposes, though, I'll provide a simple summary: <i>&quot;Cellular Automata are a collection (usually a grid) of tiles, each with some kind of discrete state. The states of tiles change over the course of cycles (iterations) based on the states of their neighbors.&quot;</i>
        </p>
        <p>
            In the case of this algorithm, we use cellular automaton with similar rules to <a href="https://bitstorm.org/gameoflife/">Conway's Game of Life</a>.
            Our cellular automaton will mark non-solid tiles as solid if enough adjacent tiles are already solid, and vice-versa.
            At the start of each cycle, we also mark a random number of non-solid tiles as solid, based on a given percentage.
            This has the effect of eroding away passable areas and smoothing them out at the same time:
        </p>
        <img class="center-screenshot" src="roguelike_04_02.png" alt="A screenshot displaying the results of the erosion technique: Large, mostly open caverns with occasional tighter spaces"/>
<pre class="hl">
<span class="hl lin">   49 </span><span class="hl kwb">void</span> <span class="hl kwd">map_generate_erode</span><span class="hl opt">(</span>map<span class="hl opt">*</span> m<span class="hl opt">,</span> actor<span class="hl opt">*</span> a<span class="hl opt">) {</span>
<span class="hl lin">   50 </span>    <span class="hl kwb">int</span> passcount         <span class="hl opt">=</span> <span class="hl num">3</span><span class="hl opt">;</span>  <span class="hl slc">// How many passes to perform</span>
<span class="hl lin">   51 </span>    <span class="hl kwb">int</span> ratio             <span class="hl opt">=</span> <span class="hl num">45</span><span class="hl opt">;</span> <span class="hl slc">// Percentage of solid tiles to shoot for each pass</span>
<span class="hl lin">   52 </span>    <span class="hl kwb">int</span> min_neighbors     <span class="hl opt">=</span> <span class="hl num">5</span><span class="hl opt">;</span>  <span class="hl slc">// How many neighbors are needed to stay non-solid</span>
<span class="hl lin">   53 </span>    <span class="hl kwb">int</span> min_neighbors_non <span class="hl opt">=</span> <span class="hl num">3</span><span class="hl opt">;</span>  <span class="hl slc">// How many neighbors are needed to stay solid</span>
<span class="hl lin">   54 </span>
<span class="hl lin">   55 </span>    <span class="hl slc">// Empty the map, but keep the edges solid</span>
<span class="hl lin">   56 </span>    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> m<span class="hl opt">-&gt;</span>lines<span class="hl opt">; ++</span>i<span class="hl opt">) {</span>
<span class="hl lin">   57 </span>        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> m<span class="hl opt">-&gt;</span>columns<span class="hl opt">; ++</span>j<span class="hl opt">) {</span>
<span class="hl lin">   58 </span>            <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">0</span> <span class="hl opt">||</span> i <span class="hl opt">==</span> m<span class="hl opt">-&gt;</span>lines <span class="hl opt">-</span> <span class="hl num">1</span> <span class="hl opt">||</span> j <span class="hl opt">==</span> <span class="hl num">0</span> <span class="hl opt">||</span> j <span class="hl opt">==</span> m<span class="hl opt">-&gt;</span>columns <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">) {</span>
<span class="hl lin">   59 </span>                m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid <span class="hl opt">=</span> TRUE<span class="hl opt">;</span>
<span class="hl lin">   60 </span>                m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>character <span class="hl opt">=</span> <span class="hl num">219</span><span class="hl opt">;</span>
<span class="hl lin">   61 </span>            <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span>
<span class="hl lin">   62 </span>                m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid <span class="hl opt">=</span> FALSE<span class="hl opt">;</span>
<span class="hl lin">   63 </span>                m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>character <span class="hl opt">=</span> <span class="hl str">&apos;.&apos;</span><span class="hl opt">;</span>
<span class="hl lin">   64 </span>            <span class="hl opt">}</span>
<span class="hl lin">   65 </span>        <span class="hl opt">}</span>
<span class="hl lin">   66 </span>    <span class="hl opt">}</span>
<span class="hl lin">   67 </span>
<span class="hl lin">   68 </span>    <span class="hl slc">// Passes</span>
<span class="hl lin">   69 </span>    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> pass <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> pass <span class="hl opt">&lt;</span> passcount<span class="hl opt">; ++</span>pass<span class="hl opt">) {</span>
<span class="hl lin">   70 </span>        <span class="hl slc">// Fill empty spaces with some percentage (ratio) of solid tiles</span>
<span class="hl lin">   71 </span>        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> m<span class="hl opt">-&gt;</span>lines <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">; ++</span>i<span class="hl opt">) {</span>
<span class="hl lin">   72 </span>            <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> m<span class="hl opt">-&gt;</span>columns <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">; ++</span>j<span class="hl opt">) {</span>
<span class="hl lin">   73 </span>                <span class="hl kwa">if</span><span class="hl opt">(!</span>m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid<span class="hl opt">) {</span>
<span class="hl lin">   74 </span>                    m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid <span class="hl opt">=</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">100</span> <span class="hl opt">&lt;</span> ratio<span class="hl opt">;</span>
<span class="hl lin">   75 </span>                    m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>character <span class="hl opt">=</span> m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid <span class="hl opt">?</span> <span class="hl num">219</span> <span class="hl opt">:</span> <span class="hl str">&apos;.&apos;</span><span class="hl opt">;</span>
<span class="hl lin">   76 </span>                <span class="hl opt">}</span>
<span class="hl lin">   77 </span>            <span class="hl opt">}</span>
<span class="hl lin">   78 </span>        <span class="hl opt">}</span>
<span class="hl lin">   79 </span>
<span class="hl lin">   80 </span>        <span class="hl slc">// Run the Cellular Automaton</span>
<span class="hl lin">   81 </span>        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> m<span class="hl opt">-&gt;</span>lines <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">; ++</span>i<span class="hl opt">) {</span>
<span class="hl lin">   82 </span>            <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> m<span class="hl opt">-&gt;</span>columns <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">; ++</span>j<span class="hl opt">) {</span>
<span class="hl lin">   83 </span>                <span class="hl kwa">if</span><span class="hl opt">(</span>m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid<span class="hl opt">) {</span>
<span class="hl lin">   84 </span>                    <span class="hl slc">// Get the number of similar neighbors</span>
<span class="hl lin">   85 </span>                    <span class="hl kwb">int</span> neighbors <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl lin">   86 </span>                    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> k <span class="hl opt">= -</span><span class="hl num">1</span><span class="hl opt">;</span> k <span class="hl opt">&lt;</span> <span class="hl num">2</span><span class="hl opt">; ++</span>k<span class="hl opt">) {</span>
<span class="hl lin">   87 </span>                        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> l <span class="hl opt">= -</span><span class="hl num">1</span><span class="hl opt">;</span> l <span class="hl opt">&lt;</span> <span class="hl num">2</span><span class="hl opt">; ++</span>l<span class="hl opt">) {</span>
<span class="hl lin">   88 </span>                            <span class="hl kwa">if</span><span class="hl opt">(</span>m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i <span class="hl opt">+</span> k<span class="hl opt">][</span>j <span class="hl opt">+</span> l<span class="hl opt">].</span>solid<span class="hl opt">)</span>
<span class="hl lin">   89 </span>                                neighbors<span class="hl opt">++;</span>
<span class="hl lin">   90 </span>                        <span class="hl opt">}</span>
<span class="hl lin">   91 </span>                    <span class="hl opt">}</span>
<span class="hl lin">   92 </span>
<span class="hl lin">   93 </span>                    m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid <span class="hl opt">=</span> neighbors <span class="hl opt">&gt;=</span> min_neighbors<span class="hl opt">;</span>
<span class="hl lin">   94 </span>                    m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>character <span class="hl opt">=</span> m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid <span class="hl opt">?</span> <span class="hl num">219</span> <span class="hl opt">:</span> <span class="hl str">&apos;.&apos;</span><span class="hl opt">;</span>
<span class="hl lin">   95 </span>                <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span>
<span class="hl lin">   96 </span>                    <span class="hl slc">// Get the number of similar neighbors</span>
<span class="hl lin">   97 </span>                    <span class="hl kwb">int</span> neighbors <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl lin">   98 </span>                    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> k <span class="hl opt">= -</span><span class="hl num">1</span><span class="hl opt">;</span> k <span class="hl opt">&lt;</span> <span class="hl num">2</span><span class="hl opt">; ++</span>k<span class="hl opt">) {</span>
<span class="hl lin">   99 </span>                        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> l <span class="hl opt">= -</span><span class="hl num">1</span><span class="hl opt">;</span> l <span class="hl opt">&lt;</span> <span class="hl num">2</span><span class="hl opt">; ++</span>l<span class="hl opt">) {</span>
<span class="hl lin">  100 </span>                            <span class="hl kwa">if</span><span class="hl opt">(!</span>m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i <span class="hl opt">+</span> k<span class="hl opt">][</span>j <span class="hl opt">+</span> l<span class="hl opt">].</span>solid<span class="hl opt">)</span>
<span class="hl lin">  101 </span>                                neighbors<span class="hl opt">++;</span>
<span class="hl lin">  102 </span>                        <span class="hl opt">}</span>
<span class="hl lin">  103 </span>                    <span class="hl opt">}</span>
<span class="hl lin">  104 </span>
<span class="hl lin">  105 </span>                    m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid <span class="hl opt">=</span> neighbors <span class="hl opt">&lt;</span> min_neighbors_non<span class="hl opt">;</span>
<span class="hl lin">  106 </span>                    m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>character <span class="hl opt">=</span> m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid <span class="hl opt">?</span> <span class="hl num">219</span> <span class="hl opt">:</span> <span class="hl str">&apos;.&apos;</span><span class="hl opt">;</span>
<span class="hl lin">  107 </span>                <span class="hl opt">}</span>
<span class="hl lin">  108 </span>            <span class="hl opt">}</span>
<span class="hl lin">  109 </span>        <span class="hl opt">}</span>
<span class="hl lin">  110 </span>    <span class="hl opt">}</span>
<span class="hl lin">  111 </span>
<span class="hl lin">  112 </span>    <span class="hl slc">// Second cleanup pass</span>
<span class="hl lin">  113 </span>    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> m<span class="hl opt">-&gt;</span>lines <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">; ++</span>i<span class="hl opt">) {</span>
<span class="hl lin">  114 </span>        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> m<span class="hl opt">-&gt;</span>columns <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">; ++</span>j<span class="hl opt">) {</span>
<span class="hl lin">  115 </span>            <span class="hl kwa">if</span><span class="hl opt">(</span>m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid<span class="hl opt">) {</span>
<span class="hl lin">  116 </span>                <span class="hl kwb">int</span> neighbors <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl lin">  117 </span>                <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> k <span class="hl opt">= -</span><span class="hl num">1</span><span class="hl opt">;</span> k <span class="hl opt">&lt;</span> <span class="hl num">2</span><span class="hl opt">; ++</span>k<span class="hl opt">) {</span>
<span class="hl lin">  118 </span>                    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> l <span class="hl opt">= -</span><span class="hl num">1</span><span class="hl opt">;</span> l <span class="hl opt">&lt;</span> <span class="hl num">2</span><span class="hl opt">; ++</span>l<span class="hl opt">) {</span>
<span class="hl lin">  119 </span>                        <span class="hl kwa">if</span><span class="hl opt">(</span>m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i <span class="hl opt">+</span> k<span class="hl opt">][</span>j <span class="hl opt">+</span> l<span class="hl opt">].</span>solid<span class="hl opt">)</span>
<span class="hl lin">  120 </span>                            neighbors<span class="hl opt">++;</span>
<span class="hl lin">  121 </span>                    <span class="hl opt">}</span>
<span class="hl lin">  122 </span>                <span class="hl opt">}</span>
<span class="hl lin">  123 </span>
<span class="hl lin">  124 </span>                m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid <span class="hl opt">=</span> neighbors <span class="hl opt">&gt;=</span> min_neighbors<span class="hl opt">;</span>
<span class="hl lin">  125 </span>                m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>character <span class="hl opt">=</span> m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid <span class="hl opt">?</span> <span class="hl num">219</span> <span class="hl opt">:</span> <span class="hl str">&apos;.&apos;</span><span class="hl opt">;</span>
<span class="hl lin">  126 </span>            <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span>
<span class="hl lin">  127 </span>                <span class="hl kwb">int</span> neighbors <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl lin">  128 </span>                <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> k <span class="hl opt">= -</span><span class="hl num">1</span><span class="hl opt">;</span> k <span class="hl opt">&lt;</span> <span class="hl num">2</span><span class="hl opt">; ++</span>k<span class="hl opt">) {</span>
<span class="hl lin">  129 </span>                    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> l <span class="hl opt">= -</span><span class="hl num">1</span><span class="hl opt">;</span> l <span class="hl opt">&lt;</span> <span class="hl num">2</span><span class="hl opt">; ++</span>l<span class="hl opt">) {</span>
<span class="hl lin">  130 </span>                        <span class="hl kwa">if</span><span class="hl opt">(!</span>m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i <span class="hl opt">+</span> k<span class="hl opt">][</span>j <span class="hl opt">+</span> l<span class="hl opt">].</span>solid<span class="hl opt">)</span>
<span class="hl lin">  131 </span>                            neighbors<span class="hl opt">++;</span>
<span class="hl lin">  132 </span>                    <span class="hl opt">}</span>
<span class="hl lin">  133 </span>                <span class="hl opt">}</span>
<span class="hl lin">  134 </span>
<span class="hl lin">  135 </span>                m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid <span class="hl opt">=</span> neighbors <span class="hl opt">&lt;</span> min_neighbors_non<span class="hl opt">;</span>
<span class="hl lin">  136 </span>                m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>character <span class="hl opt">=</span> m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>solid <span class="hl opt">?</span> <span class="hl num">219</span> <span class="hl opt">:</span> <span class="hl str">&apos;.&apos;</span><span class="hl opt">;</span>
<span class="hl lin">  137 </span>            <span class="hl opt">}</span>
<span class="hl lin">  138 </span>        <span class="hl opt">}</span>
<span class="hl lin">  139 </span>    <span class="hl opt">}</span>
<span class="hl lin">  140 </span><span class="hl opt">}</span>
</pre>
        <h3>Benefits</h3>
        <ul>
            <li>Tends to make smooth caverns, rather than the drunkard's walk's twisting passages.</li>
            <li>Passable areas are well distributed across a map.</li>
            <li>No extra work is needed to avoid sharp, cut-off edges.</li>
            <li>Takes a constant, predictable length of time to generate.</li>
        </ul>

        <h3>Drawbacks</h3>
        <ul>
            <li>Levels are <b>not</b> necessarily contiguous. In other words, the generator can create pockets with no connection to the rest of the level. The only perfect way of dealing with this is using a &quot;flood fill&quot; (like the fill tool in most art programs) to find and analyze different segments to find the most viable one.</li>
            <li>The results are less varied than the drunkard's walk, and using this algorithm alone could be pretty boring.</li>
            <li>Much more complicated to write than the drunkard's walk, and the numerous iterations can make it notably slower.
        </ul>

        <h2>Conclusion</h2>
        <p>
            I hope this segment has opened your eyes a bit with regards to procedural generation.
            The notion of letting the computer create content may seem frighteningly complex, but in reality there are plenty of simple algorithms that can produce great results.
            It's important to remember, however, that this tutorial series is meant as a starting point for you to build your own game.
            Rather than simply taking the algorithms and code that I show here directly, it's important to tweak and modify them to properly suit your needs.
            Nothing's stopping you from adding new steps to an algorithm, modifying the results, or even combining several algorithms at once.
            In the next segment, I'll be applying this advice to create a more polished level generator.
        </p>

        <h2>Next Steps</h2>
        <ol>
            <li>Try to fix our two generators. The drunkard's walk generator can potentially take a long time, so giving a cutoff value for iterations is important. For the eroding generator, try to make it fill in all but the largest open space, then move the player inside.</li>
        </ol>

        <h2>Code</h2>
        <p>To download the code as of this part, <a href="https://github.com/Df458/Dark-Lands/archive/5f415c5432c7b05a075974dd28f58a87d730bc08.zip">click here</a>.</p>

        <div class="tnav-flex">
            <a href="roguelike_03.html" rel="prev"><img class="txt-icon" src="../img/prev.svg">Previous</a>
            <a href="roguelike_index.html">Index</a>
            <a href="roguelike_05.html" rel="next">Next<img class="txt-icon" src="../img/next.svg"></a>
        </div>
    </main>
    </body>
</html>
