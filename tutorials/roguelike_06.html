<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel='stylesheet' href='../theme.css'>
        <link rel='stylesheet' href='../main.css'>
        <link rel='stylesheet' href='../tutorials.css'>
        <link rel='stylesheet' href='../highlight.css'>
        <link rel='icon' href='../icon.png' sizes="192x192">
        <meta name="theme-color" content="#202020">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <script src="popup_close.js"></script>
    <title>Hugues Ross - Tutorials</title>
    </head>
    <body>
    <header>
        <a id="main-name" href="../index.html">Hugues Ross</a>
        <div class="main-nav">
            <a class="nav-entry" href="../about.html">About</a>
            <a class="nav-entry" href="http://www.huguesross.net">Blog</a>
            <a class="nav-entry selected" href="../tutorials.html">Tutorials</a>
            <a class="nav-entry" href="../software.html">Software</a>
            <a class="nav-entry" href="../games.html">Games</a>
        </div>
    </header>
    <!-- Main Area -->
    <main role="main">
        <div class="tnav-flex">
            <a href="roguelike_05.html" rel="prev">Previous Part</a>
            <a href="roguelike_index.html">Index</a>
            <a href="#" rel="next" class="tnav-spacer" aria-hidden="true">Next Part</a>
            <!-- <a href="roguelike_07.html" rel="next">Next Part</a> -->
        </div>
        <h1>Let's Make a Roguelike - 6 - Stats, Items, and Messages</h1>
        <p>
            In the previous segment, we looked at the process of designing and implementing a level.
            This time, we'll be putting that aside for a while to cover an important aspect of many roguelikes: Stats.
            Stats may not the most glorious or exciting of topics, but representing characters and objects with numbers is an integral part of many games.
            For this reason we'll be giving our character some stats, and creating items and equipment to modify those stats.
        </p>

        <h2>Stats</h2>
        <p>
            Having likely played videogames before, I'm sure you know what stats are.
            However, to make sure that we're all on the same page I'm going to give my own definition:
        </p>
        <q>Stats are the numerical representation of an object's capabilities.</q>
        <p>
            That object could be a character, a sword, a magical potion, or simply a lever that resets itself after a while.
            As long as the numbers represent what the object does, or can do, they're stats.
            What stats you actually use in your roguelike can vary wildly depending on the scope of the mechanics that you've chosen.
            Some roguelikes track almost nothing, and then you have cases like <i>Dungeons of Dredmor</i>:
        </p>
        <img class="center-screenshot" src="roguelike_06_01.png" alt="A character sheet from Dungeons of Dredmor, featuring dozens of numbers"/>
        <p>
            Thankfully, adding stats to something in code is about as straightforward as just adding the necessary values to its struct.
            In the case of this tutorial, I'll be keeping the stats (and by extension, the eventual combat mechanics) simple and minimal, so the resulting actor struct looks like this:
        </p>
<pre class=hl>
<span class="hl lin">    6 </span><span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> actor <span class="hl opt">{</span>
<span class="hl lin">    7 </span>    <span class="hl kwb">uint8_t</span> character<span class="hl opt">;</span>
<span class="hl lin">    8 </span>    point position<span class="hl opt">;</span>
<span class="hl lin">    9 </span>    <span class="hl kwb">int</span> color_pair<span class="hl opt">;</span>
<span class="hl lin">   10 </span>
<span class="hl lin">   11 </span>    <span class="hl kwb">uint16_t</span> level<span class="hl opt">;</span>
<span class="hl lin">   12 </span>    <span class="hl kwb">uint16_t</span> xp<span class="hl opt">;</span>
<span class="hl lin">   13 </span>    <span class="hl kwb">uint16_t</span> hp<span class="hl opt">;</span>
<span class="hl lin">   14 </span>    <span class="hl kwb">uint16_t</span> hp_max<span class="hl opt">;</span>
<span class="hl lin">   15 </span>    <span class="hl kwb">uint16_t</span> attack<span class="hl opt">;</span>
<span class="hl lin">   16 </span>    <span class="hl kwb">uint16_t</span> defense<span class="hl opt">;</span>
<span class="hl lin">   17 </span><span class="hl opt">}</span> actor<span class="hl opt">;</span>
</pre>
        <p>
            How quick!
            Of course, I wouldn't end a tutorial segment so quickly.
            Stats are all well and good, but the player won't understand the stats in your game unless present them somehow.
            To that end, let's add a UI to our game.
        </p>

        <h2>UI</h2>
        <p>
            Like many aspects of roguelikes, there's really no hard and fast rule about how your UI should look and act.
            As an example, I'll be recreating the UI from <a href="../games.html#to-the-west"><i>To the West</i></a>, which should give a nice example to use as a jumping-off point.
            For reference, this is what the game's UI looks like:
        </p>
        <img class="center-screenshot" src="roguelike_06_02.gif" alt="An animation showing the different UI elements of To the West"/>

        <h3>Introducion to Windows and Panels</h3>
        <p>
            Before we build our UI, we need to cover two new curses features: Windows and Panels.
            Windows are a way to organize our draws in a more manageable format.
            Each window has its own coordinates, so drawing to the position 0,0 in a window will draw to that window's upper-left corner rather than the screen's.
            Windows can also be redrawn separately.
        </p>
        <p>
            To manage windows, curses provides a few functions.
            Here are the ones you'll probably need to care about:
        </p>
        <ul>
            <li><b>newwin(lines, cols, y, x)</b> - Creates a new window with the given size and position.</li>
            <li><b>mvwin(win, y, x)</b> - Moves a window</li>
            <li><b>delwin(win)</b> - Deletes a window, freeing the memory that it was using.</li>
        </ul>
        <p>
            With these functions in hand, you can create windows to your heart's content.
            In addition, as I pointed out back in <a href="roguelike_02.html">part 2</a>, the 'w' prefix is available on many functions in order to target a particular window.
            For instance, <b>mvaddch()</b> draws a character at a given position, but <b>mvwaddch</b> also lets you specify a window.
        </p>
        <p>
            Windows <b>do</b> come with one serious restriction: They can't overlap nicely.
            It's possible to split up an area with windows, but as soon as they overlap it becomes difficult to control what gets drawn "on top".
            For this reason, the panel extension to curses was created.
            By creating panels and attaching windows to them, window ordering and drawing can be easily managed.
            Rather than explaining in a more in-depth fashion, let's step through an example:
        </p>
        <img class="center-screenshot" src="roguelike_06_03.png" alt="Two panels overlapping each other"/>
        <p>
            This image was created with the following code:
        </p>
<pre class="hl">
<span class="hl lin">   88 </span>    WINDOW<span class="hl opt">*</span> window_1 <span class="hl opt">=</span> <span class="hl kwd">newwin</span><span class="hl opt">(</span><span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl lin">   89 </span>    PANEL<span class="hl opt">*</span> panel_1 <span class="hl opt">=</span> <span class="hl kwd">new_panel</span><span class="hl opt">(</span>window_1<span class="hl opt">);</span>
<span class="hl lin">   90 </span>    WINDOW<span class="hl opt">*</span> window_2 <span class="hl opt">=</span> <span class="hl kwd">newwin</span><span class="hl opt">(</span><span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">6</span><span class="hl opt">);</span>
<span class="hl lin">   91 </span>    PANEL<span class="hl opt">*</span> panel_2 <span class="hl opt">=</span> <span class="hl kwd">new_panel</span><span class="hl opt">(</span>window_2<span class="hl opt">);</span>
<span class="hl lin">   92 </span>    <span class="hl kwd">top_panel</span><span class="hl opt">(</span>panel_1<span class="hl opt">);</span>
<span class="hl lin">   93 </span>    <span class="hl kwd">box</span><span class="hl opt">(</span>window_1<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl lin">   94 </span>    <span class="hl kwd">box</span><span class="hl opt">(</span>window_2<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl lin">   95 </span>    <span class="hl kwd">update_panels</span><span class="hl opt">();</span>
<span class="hl lin">   96 </span>    <span class="hl kwd">doupdate</span><span class="hl opt">();</span>
<span class="hl lin">   97 </span>
<span class="hl lin">   98 </span>    <span class="hl kwd">getch</span><span class="hl opt">();</span>
<span class="hl lin">   99 </span>
<span class="hl lin">  100 </span>    <span class="hl kwd">del_panel</span><span class="hl opt">(</span>panel_1<span class="hl opt">);</span>
<span class="hl lin">  101 </span>    <span class="hl kwd">del_panel</span><span class="hl opt">(</span>panel_2<span class="hl opt">);</span>
<span class="hl lin">  102 </span>    <span class="hl kwd">delwin</span><span class="hl opt">(</span>window_1<span class="hl opt">);</span>
<span class="hl lin">  103 </span>    <span class="hl kwd">delwin</span><span class="hl opt">(</span>window_2<span class="hl opt">);</span>
</pre>
        <p>
            We start by creating our windows and panels.
            By calling <b>new_panel(win)</b>, we create a new panel with the provided window attached.
            By default, this new panel is placed on top of all the others, so after these calls our panels are ordered like so:
        </p>
        <ol>
            <li>window_2</li>
            <li>window_1</li>
        </ol>
        <p>
            By using the <b>top_panel(panel)</b> function, we move the panel containing window_1 to the top.
            In our case, this reverses the order.
            However, this order won't apply to the screen until we call <b>update_panels()</b> later in this example.
            After that, the windows are given borders to draw via the <b>box(win, v, h)</b> function.
            This function draws a border around the given window, and accepts characters to use for the lines.
            If you leave the values at 0, you get a nice default box that works well for text UIs, which is what I used in <i>To the West</i>.
        </p>
        <p>
            This alone won't be enough to display anything onscreen, however.
            Unlike drawing to the screen directly, drawing to a window doesn't display anything.
            There are several functions to make one or more windows appear, but this case I used <b>update_panels()</b> followed by <b>doupdate()</b>.
        </p>

        <aside class="note">
            <h4 class="note-heading">Note - What does doupdate() do?</h4>
            This particular tidbit isn't too important, but it <i>does</i> give an interesting insight into how curses works.
            Curses actually has two different screens that it draws to, the screen that you can see, and a so-called "virtual screen".
            You can think of the latter as a staging area for the content that you want to draw: You add all of your changes to the virtual screen, then move them to the main screen all at once for improved performance.
            For obvious reasons, each window that you create tracks its contents as well.
            <br/>
            <br/>
            The <b>doupdate()</b> function is the function that handles putting the virtual screen'ss contents onto the main screen.
            To get the changes from a window to the virtual screen, the <b>wnoutrefresh(win)</b> function needs to be used.
            Note, however, that I said <i>changes</i>.
            In some implementations of curses, the entire window is redrawn.
            In others, only changed lines are redrawn.
            This means that if two windows share a corner, the one that's "on top" may not put anything on the virtual screen, and the bottom one might, causing characters to potentially bleed through.
            This is why the panels library is necessary, which brings me to <b>update_panels()</b>.
            What this function really does is copy the changes from each panel to the virtual screen, ensuring that each usage of <b>wnoutrefresh()</b> is done in the right order.
            Incidentally, this is also why <b>update_panels()</b> doesn't cause anything to appear without a <b>doupdate()</b> call.
            <br/>
            <br/>
            At least... that's my understanding of how curses works.
            I don't have enough experience to say that this is 100% correct, but it seems to be what the documentation implies.
        </aside>

        <p>
            There's not much to say about <b>del_panel(panel)</b> and <b>delwin(win)</b>, besides a reminder to call them for each window/panel pair when your done with it.
        </p>

        <h3>Building the UI</h3>
        <p>
            Now that the long explanation is over, let's use our newfound knowledge to recreate <i>To the West's</i> UI.
            If you haven't already, you'll want to update the drawing functions to draw to a provided window.
            Once that's done, we can begin by finishing up the map window.
            As you saw earlier, the frame around the map can be easily replicated by calling <b>box(win, v, h)</b> after drawing the map.
        </p>
        <p>
            The last piece of the puzzle is the HP (or anything else you want to add) counter, which requires another small callback to part 2.
            If you recall the first code sample, we used a function called <b>printw(format, ...)</b> to display a message on screen.
            This function is the curses equivalent to printf, so we can draw a health indicator quite easily with it:
        </p>
<pre class="hl">
<span class="hl kwd">mvwprintw</span><span class="hl opt">(</span>window<span class="hl opt">,</span> line<span class="hl opt">,</span> column<span class="hl opt">,</span> <span class="hl str">&quot;%d/%d&quot;</span><span class="hl opt">,</span> player<span class="hl opt">.</span>hp<span class="hl opt">,</span> player<span class="hl opt">.</span>hp_max<span class="hl opt">);</span></pre>
        <p>
            Bringing it all together, here's the code that draws the map and health indicator:
        </p>
<pre class="hl">
<span class="hl lin">   13 </span><span class="hl kwb">void</span> <span class="hl kwd">draw_game</span><span class="hl opt">() {</span>
<span class="hl lin">   14 </span>    <span class="hl kwd">wclear</span><span class="hl opt">(</span>map_window<span class="hl opt">);</span>
<span class="hl lin">   15 </span>    <span class="hl kwd">map_draw</span><span class="hl opt">(</span>map_window<span class="hl opt">,</span> game_map<span class="hl opt">,</span> player<span class="hl opt">);</span>
<span class="hl lin">   16 </span>    <span class="hl kwd">actor_draw</span><span class="hl opt">(</span>map_window<span class="hl opt">,</span> player<span class="hl opt">,</span> game_map<span class="hl opt">,</span> player<span class="hl opt">);</span>
<span class="hl lin">   17 </span>    <span class="hl kwd">box</span><span class="hl opt">(</span>map_window<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl lin">   18 </span>    <span class="hl kwd">wmove</span><span class="hl opt">(</span>map_window<span class="hl opt">,</span> player<span class="hl opt">-&gt;</span>position<span class="hl opt">.</span>line<span class="hl opt">,</span> player<span class="hl opt">-&gt;</span>position<span class="hl opt">.</span>column<span class="hl opt">);</span> <span class="hl slc">// Place the cursor on the player</span>
<span class="hl lin">   19 </span>
<span class="hl lin">   20 </span>    <span class="hl kwd">mvwprintw</span><span class="hl opt">(</span>map_window<span class="hl opt">,</span> <span class="hl num">19</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl str">&quot;HP: %d/%d&quot;</span><span class="hl opt">,</span> player<span class="hl opt">-&gt;</span>hp<span class="hl opt">,</span> player<span class="hl opt">-&gt;</span>hp_max<span class="hl opt">);</span>
<span class="hl lin">   21 </span>
<span class="hl lin">   22 </span>    <span class="hl kwd">update_panels</span><span class="hl opt">();</span>
<span class="hl lin">   23 </span>    <span class="hl kwd">doupdate</span><span class="hl opt">();</span>
<span class="hl lin">   24 </span><span class="hl opt">}</span>
</pre>

        <h2>The Stats Panel</h2>
        <p>
            Now that the indicators on the map window are done, let's give the player a simple way to review their stats.
            To do that, we're going to use a little trick that I like.
            You see, one of the most interesting differences between most curses games and regular non text-based games (in my opinion) is that rather than looping at a set rate, the games wait for player input on each iteration of the main loop instead.
            This means that the games typically have little to no concept of change over time or motion.
            As a result, you can create a function that builds a window, runs a special input/drawing loop just for it, then cleans up and returns to the main loop.
            This simplifies the process of creating and handling new windows, and as a result you can make a simple function like this:
        </p>
<pre class="hl">
<span class="hl lin">   41 </span><span class="hl kwb">void</span> <span class="hl kwd">stats_panel</span><span class="hl opt">(</span>actor<span class="hl opt">*</span> a<span class="hl opt">) {</span>
<span class="hl lin">   42 </span>    WINDOW<span class="hl opt">*</span> stats_window <span class="hl opt">=</span> <span class="hl kwd">newwin</span><span class="hl opt">(</span><span class="hl num">25</span><span class="hl opt">,</span> <span class="hl num">40</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">40</span><span class="hl opt">);</span>
<span class="hl lin">   43 </span>    PANEL<span class="hl opt">*</span> stats_panel <span class="hl opt">=</span> <span class="hl kwd">new_panel</span><span class="hl opt">(</span>stats_window<span class="hl opt">);</span>
<span class="hl lin">   44 </span>
<span class="hl lin">   45 </span>    <span class="hl kwd">top_panel</span><span class="hl opt">(</span>stats_panel<span class="hl opt">);</span>
<span class="hl lin">   46 </span>
<span class="hl lin">   47 </span>    <span class="hl kwa">do</span> <span class="hl opt">{</span>
<span class="hl lin">   48 </span>        <span class="hl kwd">wclear</span><span class="hl opt">(</span>stats_window<span class="hl opt">);</span>
<span class="hl lin">   49 </span>        <span class="hl kwd">box</span><span class="hl opt">(</span>stats_window<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl lin">   50 </span>
<span class="hl lin">   51 </span>        <span class="hl kwd">mvwaddch</span><span class="hl opt">(</span>stats_window<span class="hl opt">,</span> <span class="hl num">22</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">195</span><span class="hl opt">);</span>
<span class="hl lin">   52 </span>        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">39</span><span class="hl opt">; ++</span>i<span class="hl opt">)</span>
<span class="hl lin">   53 </span>            <span class="hl kwd">mvwaddch</span><span class="hl opt">(</span>stats_window<span class="hl opt">,</span> <span class="hl num">22</span><span class="hl opt">,</span> i<span class="hl opt">,</span> <span class="hl num">196</span><span class="hl opt">);</span>
<span class="hl lin">   54 </span>        <span class="hl kwd">mvwaddch</span><span class="hl opt">(</span>stats_window<span class="hl opt">,</span> <span class="hl num">22</span><span class="hl opt">,</span> <span class="hl num">39</span><span class="hl opt">,</span> <span class="hl num">180</span><span class="hl opt">);</span>
<span class="hl lin">   55 </span>        <span class="hl kwd">mvwaddstr</span><span class="hl opt">(</span>stats_window<span class="hl opt">,</span> <span class="hl num">23</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl str">&quot;q to exit&quot;</span><span class="hl opt">);</span>
<span class="hl lin">   56 </span>
<span class="hl lin">   57 </span>        <span class="hl kwd">mvwprintw</span><span class="hl opt">(</span>stats_window<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl str">&quot;Level:</span><span class="hl esc">\t</span><span class="hl str">%u (%u/%u)&quot;</span><span class="hl opt">,</span> a<span class="hl opt">-&gt;</span>level<span class="hl opt">,</span> a<span class="hl opt">-&gt;</span>xp<span class="hl opt">,</span> <span class="hl num">100</span><span class="hl opt">);</span>
<span class="hl lin">   58 </span>        <span class="hl kwd">mvwprintw</span><span class="hl opt">(</span>stats_window<span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl str">&quot;Health:</span><span class="hl esc">\t</span><span class="hl str">%u/%u&quot;</span><span class="hl opt">,</span> a<span class="hl opt">-&gt;</span>hp<span class="hl opt">,</span> a<span class="hl opt">-&gt;</span>hp_max<span class="hl opt">);</span>
<span class="hl lin">   59 </span>        <span class="hl kwd">mvwprintw</span><span class="hl opt">(</span>stats_window<span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl str">&quot;Attack:</span><span class="hl esc">\t</span><span class="hl str">%u&quot;</span><span class="hl opt">,</span> a<span class="hl opt">-&gt;</span>attack<span class="hl opt">);</span>
<span class="hl lin">   60 </span>        <span class="hl kwd">mvwprintw</span><span class="hl opt">(</span>stats_window<span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl str">&quot;Defense:</span><span class="hl esc">\t</span><span class="hl str">%u&quot;</span><span class="hl opt">,</span> a<span class="hl opt">-&gt;</span>defense<span class="hl opt">);</span>
<span class="hl lin">   61 </span>
<span class="hl lin">   62 </span>        <span class="hl kwd">update_panels</span><span class="hl opt">();</span>
<span class="hl lin">   63 </span>        <span class="hl kwd">doupdate</span><span class="hl opt">();</span>
<span class="hl lin">   64 </span>    <span class="hl opt">}</span> <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getch</span><span class="hl opt">() !=</span> <span class="hl str">&apos;q&apos;</span><span class="hl opt">);</span>
<span class="hl lin">   65 </span>
<span class="hl lin">   66 </span>    <span class="hl kwd">del_panel</span><span class="hl opt">(</span>stats_panel<span class="hl opt">);</span>
<span class="hl lin">   67 </span>    <span class="hl kwd">delwin</span><span class="hl opt">(</span>stats_window<span class="hl opt">);</span>
<span class="hl lin">   68 </span><span class="hl opt">}</span>
</pre>
        <p>
            That handles all the necessary logic for a window like this:
        </p>
        <img class="center-screenshot" src="roguelike_06_04.png" alt="The stats window"/>

        <h2>Inventory & Items</h2>
        <p>
            Next, let's make an inventory.
            To do that, we'll need to give the player some items.
            There are a number of ways to handle items depending on what you're aiming to do, so I'll show you a fairly generic way to implement them.
        </p>

        <h3>Making Items</h3>
        <p>
            Items in roguelikes can often do quite a bit, which can make them tricky.
            The main source of complexity is the fact that items can often have a number of different <i>triggers</i> for their effects.
            Just look at a game like <i>Nethack</i>, and you'll quickly realize that there are items that have effects when you:
        </p>
        <ul>
            <li>Use them</li>
            <li>Eat them</li>
            <li>Equip them</li>
            <li>Hit enemies with them</li>
            <li>Throw them</li>
            <li>Read them</li>
            <li>Step on them</li>
            <li>Pick them up</li>
            <li>Write things in the dust with them</li>
            <li>...and probably more that I can't think of</li>
        </ul>
        <p>
            We're not going to make an item system that complex or robust.
            However, we can easily make items react to a few different verbs, which should be enough to get you started on your own game.
            Let's start with a very basic struct:
        </p>
<pre class="hl">
<span class="hl lin">    1 </span><span class="hl ppc">#ifndef ITEM_H</span>
<span class="hl lin">    2 </span><span class="hl ppc">#define ITEM_H</span>
<span class="hl lin">    3 </span><span class="hl ppc">#include &lt;inttypes.h&gt;</span>
<span class="hl lin">    4 </span>
<span class="hl lin">    5 </span><span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> item <span class="hl opt">{</span>
<span class="hl lin">    6 </span>    <span class="hl kwb">char</span><span class="hl opt">*</span> name<span class="hl opt">;</span>
<span class="hl lin">    7 </span>    <span class="hl kwb">uint8_t</span> character<span class="hl opt">;</span>
<span class="hl lin">    8 </span>    <span class="hl kwb">int</span> color_pair<span class="hl opt">;</span>
<span class="hl lin">    9 </span>
<span class="hl lin">   10 </span>    <span class="hl kwb">uint16_t</span> count<span class="hl opt">;</span>
<span class="hl lin">   11 </span><span class="hl opt">}</span> item<span class="hl opt">;</span>
<span class="hl lin">   12 </span>
<span class="hl lin">   13 </span><span class="hl ppc">#endif</span>
</pre>
        <p>
            We'll add more to this later.
            For now, let's get some items in a map.
            Personally, I find the easiest way to handle items in a map to be via the tiles.
            This is the main reason why our item struct doesn't need a position: It will always be kept inside a container of some kind, such as a tile or actor.
            We also need functions to add/remove items in a tile.
            I've written a very simple resizing container for this purpose, which also auto-stacks items of the same type.
            It requires a simple addition to the tile struct:
        </p>
<pre class="hl">
<span class="hl lin">    7 </span><span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> tile <span class="hl opt">{</span>
<span class="hl lin">    8 </span>    <span class="hl kwb">uint8_t</span> character<span class="hl opt">;</span>
<span class="hl lin">    9 </span>    <span class="hl kwb">int</span> color_pair<span class="hl opt">;</span>
<span class="hl lin">   10 </span>    <span class="hl kwb">bool</span> solid<span class="hl opt">;</span>
<span class="hl lin">   11 </span>
<span class="hl lin">   12 </span>    <span class="hl kwb">uint16_t</span> item_count<span class="hl opt">;</span>
<span class="hl lin">   13 </span>    <span class="hl kwb">uint16_t</span> item_slots<span class="hl opt">;</span>
<span class="hl lin">   14 </span>    item<span class="hl opt">**</span> item_list<span class="hl opt">;</span>
<span class="hl lin">   15 </span><span class="hl opt">}</span> tile<span class="hl opt">;</span>
</pre>
        <p>
            ...And the following two functions:
        </p>
<pre class="hl">
<span class="hl lin">  362 </span><span class="hl kwb">void</span> <span class="hl kwd">place_item</span><span class="hl opt">(</span>tile<span class="hl opt">*</span> t<span class="hl opt">,</span> item<span class="hl opt">*</span> it<span class="hl opt">) {</span>
<span class="hl lin">  363 </span>    <span class="hl slc">// Check for an identical item. If it exists, combine stacks and return.</span>
<span class="hl lin">  364 </span>    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> t<span class="hl opt">-&gt;</span>item_count<span class="hl opt">; ++</span>i<span class="hl opt">) {</span>
<span class="hl lin">  365 </span>        <span class="hl kwa">if</span><span class="hl opt">(!</span><span class="hl kwd">strcmp</span><span class="hl opt">(</span>t<span class="hl opt">-&gt;</span>item_list<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span>name<span class="hl opt">,</span> it<span class="hl opt">-&gt;</span>name<span class="hl opt">)) {</span>
<span class="hl lin">  366 </span>            t<span class="hl opt">-&gt;</span>item_list<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span>count <span class="hl opt">+=</span> it<span class="hl opt">-&gt;</span>count<span class="hl opt">;</span>
<span class="hl lin">  367 </span>            <span class="hl kwd">free</span><span class="hl opt">(</span>it<span class="hl opt">);</span>
<span class="hl lin">  368 </span>            <span class="hl kwa">return</span><span class="hl opt">;</span>
<span class="hl lin">  369 </span>        <span class="hl opt">}</span>
<span class="hl lin">  370 </span>    <span class="hl opt">}</span>
<span class="hl lin">  371 </span>
<span class="hl lin">  372 </span>    <span class="hl slc">// If there&apos;s no more room for items, resize the container</span>
<span class="hl lin">  373 </span>    <span class="hl kwa">if</span><span class="hl opt">(</span>t<span class="hl opt">-&gt;</span>item_count <span class="hl opt">&gt;=</span> t<span class="hl opt">-&gt;</span>item_slots<span class="hl opt">) {</span>
<span class="hl lin">  374 </span>        t<span class="hl opt">-&gt;</span>item_slots <span class="hl opt">*=</span> <span class="hl num">2</span><span class="hl opt">;</span>
<span class="hl lin">  375 </span>        t<span class="hl opt">-&gt;</span>item_list <span class="hl opt">=</span> <span class="hl kwd">realloc</span><span class="hl opt">(</span>t<span class="hl opt">-&gt;</span>item_list<span class="hl opt">,</span> t<span class="hl opt">-&gt;</span>item_slots <span class="hl opt">*</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>item<span class="hl opt">*));</span>
<span class="hl lin">  376 </span>    <span class="hl opt">}</span>
<span class="hl lin">  377 </span>
<span class="hl lin">  378 </span>    <span class="hl slc">// Place the item in the list</span>
<span class="hl lin">  379 </span>    t<span class="hl opt">-&gt;</span>item_list<span class="hl opt">[</span>t<span class="hl opt">-&gt;</span>item_count<span class="hl opt">] =</span> it<span class="hl opt">;</span>
<span class="hl lin">  380 </span>    t<span class="hl opt">-&gt;</span>item_count<span class="hl opt">++;</span>
<span class="hl lin">  381 </span><span class="hl opt">}</span>
<span class="hl lin">  382 </span>item<span class="hl opt">*</span> <span class="hl kwd">take_item</span><span class="hl opt">(</span>tile<span class="hl opt">*</span> t<span class="hl opt">,</span> <span class="hl kwb">uint16_t</span> index<span class="hl opt">) {</span>
<span class="hl lin">  383 </span>    <span class="hl kwa">if</span><span class="hl opt">(</span>t<span class="hl opt">-&gt;</span>item_count <span class="hl opt">&gt;</span> index<span class="hl opt">) {</span>
<span class="hl lin">  384 </span>        item<span class="hl opt">*</span> it <span class="hl opt">=</span> t<span class="hl opt">-&gt;</span>item_list<span class="hl opt">[</span>index<span class="hl opt">];</span>
<span class="hl lin">  385 </span>
<span class="hl lin">  386 </span>        <span class="hl slc">// Shift the items backwards. There are faster methods of filling</span>
<span class="hl lin">  387 </span>        <span class="hl slc">// space, but we want to preserve the list&apos;s order for the player&apos;s sake.</span>
<span class="hl lin">  388 </span>        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> index <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> t<span class="hl opt">-&gt;</span>item_count<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
<span class="hl lin">  389 </span>            t<span class="hl opt">-&gt;</span>item_list<span class="hl opt">[</span>i <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">] =</span> t<span class="hl opt">-&gt;</span>item_list<span class="hl opt">[</span>i<span class="hl opt">];</span>
<span class="hl lin">  390 </span>
<span class="hl lin">  391 </span>        t<span class="hl opt">-&gt;</span>item_count<span class="hl opt">--;</span>
<span class="hl lin">  392 </span>
<span class="hl lin">  393 </span>        <span class="hl kwa">return</span> it<span class="hl opt">;</span>
<span class="hl lin">  394 </span>    <span class="hl opt">}</span>
<span class="hl lin">  395 </span>
<span class="hl lin">  396 </span>    <span class="hl kwa">return</span> NULL<span class="hl opt">;</span>
<span class="hl lin">  397 </span><span class="hl opt">}</span>
</pre>
        <p>
            With those two functions, tiles can now hold items.
            Next, some actual items need to be made.
            The <i>best</i> way to spawn many custom game elements, such as items and NPCs, is to load them from data files.
            However, that could be a couple segments on its own so we'll be doing something simpler.
            For every item in our game, we can make a simple creation function that takes in the number of items to make.
            How you implement these functions is up to you, but I like having a const "template" copy of each item, and copying it with memcpy.
        </p>
        <p>
            Next up is drawing. This is quite simple, requiring only an extra if-statement when drawing a tile:
        </p>
<pre class="hl">
<span class="hl lin">  348 </span>            <span class="hl kwa">if</span><span class="hl opt">(</span>m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>item_count <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">) {</span>
<span class="hl lin">  349 </span>                <span class="hl kwd">wcolor_set</span><span class="hl opt">(</span>win<span class="hl opt">,</span> m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>color_pair<span class="hl opt">,</span> NULL<span class="hl opt">);</span>
<span class="hl lin">  350 </span>                <span class="hl kwd">mvwaddch</span><span class="hl opt">(</span>win<span class="hl opt">,</span> i <span class="hl opt">-</span> offset_y<span class="hl opt">,</span> j <span class="hl opt">-</span> offset_x<span class="hl opt">,</span> m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>character<span class="hl opt">);</span>
<span class="hl lin">  351 </span>            <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span>
<span class="hl lin">  352 </span>                item<span class="hl opt">*</span> it <span class="hl opt">=</span> m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>item_list<span class="hl opt">[</span>m<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">].</span>item_count <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">];</span>
<span class="hl lin">  353 </span>                <span class="hl kwd">wcolor_set</span><span class="hl opt">(</span>win<span class="hl opt">,</span> it<span class="hl opt">-&gt;</span>color_pair<span class="hl opt">,</span> NULL<span class="hl opt">);</span>
<span class="hl lin">  354 </span>                <span class="hl kwd">mvwaddch</span><span class="hl opt">(</span>win<span class="hl opt">,</span> i <span class="hl opt">-</span> offset_y<span class="hl opt">,</span> j <span class="hl opt">-</span> offset_x<span class="hl opt">,</span> it<span class="hl opt">-&gt;</span>character<span class="hl opt">);</span>
<span class="hl lin">  355 </span>            <span class="hl opt">}</span>
</pre>
        <p>
            The last addition that we need before we move on is giving the player an inventory.
            This gives us a convenient little excuse to refactor, by making tiles and actors use the same code for item handling.
            To do this, we can simply move the additions to the tile struct into a separate inventory struct, update the functions to take an inventory, then put an inventory into both the tile and player struct.
            In addition to making our code simpler, it also opens up the possibility of putting inventories on other objects, such as chests.
        </p>

        <h3>The Inventory Panel</h3>
        <p>
            We now have items and an inventory, but the player still can't pick them up or use them.
            To solve this problem, we're going to use the same technique as we used for the stats panel to create an inventory viewer/item selector panel.
            Unlike the stats panel, however, there are two complications to deal with: selecting items, and scrolling a potentially long list.
        </p>
        <p>
            The former issue isn't hard to solve.
            Because our inventory is in its own separate loop, we can add controls for moving a cursor and selecting an item.
            The cursor itself can just be a number that points to a slot in the item list, and when we draw each item we can simply highlight it however we like if its number matches the cursor value.
            To make the function work as a selection, we can just return the cursor value (which can then be used in take_item) at the end.
            If we allow negative cursor values, we can even return -1 to signify "cancelled" if we please.
        </p>
        <p>
            Scrolling is a little bit tougher.
            First of all, you need a second 'cursor value' to track the position of the scroll.
            Then, you need to use that value as a starting point when drawing the list of items.
            The resulting list, with a little bit of extra flair, looks like this:
        </p>
        <img class="center-screenshot" src="roguelike_06_05.gif" alt="The inventory panel, filled with test data"/>
        <p>
            And as always, here's the code:
        </p>
<pre class="hl">
<span class="hl lin">   43 </span><span class="hl kwb">int32_t</span> <span class="hl kwd">inventory_panel</span><span class="hl opt">(</span><span class="hl kwb">uint8_t</span> can_default<span class="hl opt">,</span> inventory<span class="hl opt">*</span> inv<span class="hl opt">) {</span>
<span class="hl lin">   44 </span>    <span class="hl kwa">if</span><span class="hl opt">(</span>can_default<span class="hl opt">) {</span>
<span class="hl lin">   45 </span>        <span class="hl kwa">if</span><span class="hl opt">(</span>inv<span class="hl opt">-&gt;</span>item_count <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span>
<span class="hl lin">   46 </span>            <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl lin">   47 </span>        <span class="hl kwa">else if</span><span class="hl opt">(</span>inv<span class="hl opt">-&gt;</span>item_count <span class="hl opt">==</span> <span class="hl num">1</span><span class="hl opt">)</span>
<span class="hl lin">   48 </span>            <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl lin">   49 </span>    <span class="hl opt">}</span>
<span class="hl lin">   50 </span>    <span class="hl kwb">int32_t</span> it <span class="hl opt">= -</span><span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl lin">   51 </span>    <span class="hl kwb">uint8_t</span> done <span class="hl opt">=</span> FALSE<span class="hl opt">;</span>
<span class="hl lin">   52 </span>    WINDOW<span class="hl opt">*</span> inventory_window <span class="hl opt">=</span> <span class="hl kwd">newwin</span><span class="hl opt">(</span><span class="hl num">25</span><span class="hl opt">,</span> <span class="hl num">40</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">40</span><span class="hl opt">);</span>
<span class="hl lin">   53 </span>    PANEL<span class="hl opt">*</span> inventory_panel <span class="hl opt">=</span> <span class="hl kwd">new_panel</span><span class="hl opt">(</span>inventory_window<span class="hl opt">);</span>
<span class="hl lin">   54 </span>    <span class="hl kwb">uint16_t</span> scroll_position <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl lin">   55 </span>    <span class="hl kwb">uint16_t</span> cursor_position <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl lin">   56 </span>
<span class="hl lin">   57 </span>    <span class="hl kwd">top_panel</span><span class="hl opt">(</span>inventory_panel<span class="hl opt">);</span>
<span class="hl lin">   58 </span>
<span class="hl lin">   59 </span>    <span class="hl kwa">while</span><span class="hl opt">(!</span>done<span class="hl opt">) {</span>
<span class="hl lin">   60 </span>        <span class="hl kwd">wclear</span><span class="hl opt">(</span>inventory_window<span class="hl opt">);</span>
<span class="hl lin">   61 </span>        <span class="hl kwd">box</span><span class="hl opt">(</span>inventory_window<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl lin">   62 </span>
<span class="hl lin">   63 </span>        <span class="hl kwd">mvwaddch</span><span class="hl opt">(</span>inventory_window<span class="hl opt">,</span> <span class="hl num">22</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">195</span><span class="hl opt">);</span>
<span class="hl lin">   64 </span>        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">39</span><span class="hl opt">; ++</span>i<span class="hl opt">)</span>
<span class="hl lin">   65 </span>            <span class="hl kwd">mvwaddch</span><span class="hl opt">(</span>inventory_window<span class="hl opt">,</span> <span class="hl num">22</span><span class="hl opt">,</span> i<span class="hl opt">,</span> <span class="hl num">196</span><span class="hl opt">);</span>
<span class="hl lin">   66 </span>        <span class="hl kwd">mvwaddch</span><span class="hl opt">(</span>inventory_window<span class="hl opt">,</span> <span class="hl num">22</span><span class="hl opt">,</span> <span class="hl num">39</span><span class="hl opt">,</span> <span class="hl num">180</span><span class="hl opt">);</span>
<span class="hl lin">   67 </span>        <span class="hl kwd">mvwaddstr</span><span class="hl opt">(</span>inventory_window<span class="hl opt">,</span> <span class="hl num">23</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl str">&quot;ENTER to select, q to exit&quot;</span><span class="hl opt">);</span>
<span class="hl lin">   68 </span>
<span class="hl lin">   69 </span>        <span class="hl kwa">if</span><span class="hl opt">(</span>scroll_position <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">)</span>
<span class="hl lin">   70 </span>            <span class="hl kwd">mvwaddstr</span><span class="hl opt">(</span>inventory_window<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">16</span><span class="hl opt">,</span> <span class="hl str">&quot;^ More ^&quot;</span><span class="hl opt">);</span>
<span class="hl lin">   71 </span>        <span class="hl kwa">if</span><span class="hl opt">(</span>scroll_position <span class="hl opt">+</span> <span class="hl num">21</span> <span class="hl opt">&lt;</span> inv<span class="hl opt">-&gt;</span>item_count<span class="hl opt">)</span>
<span class="hl lin">   72 </span>            <span class="hl kwd">mvwaddstr</span><span class="hl opt">(</span>inventory_window<span class="hl opt">,</span> <span class="hl num">22</span><span class="hl opt">,</span> <span class="hl num">16</span><span class="hl opt">,</span> <span class="hl str">&quot;v More v&quot;</span><span class="hl opt">);</span>
<span class="hl lin">   73 </span>
<span class="hl lin">   74 </span>        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> scroll_position<span class="hl opt">;</span> i <span class="hl opt">&lt;</span> inv<span class="hl opt">-&gt;</span>item_count <span class="hl opt">&amp;&amp;</span> i <span class="hl opt">&lt;</span> scroll_position <span class="hl opt">+</span> <span class="hl num">21</span><span class="hl opt">; ++</span>i<span class="hl opt">) {</span>
<span class="hl lin">   75 </span>            <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">==</span> cursor_position<span class="hl opt">)</span>
<span class="hl lin">   76 </span>                <span class="hl kwd">wattron</span><span class="hl opt">(</span>inventory_window<span class="hl opt">,</span> A_STANDOUT<span class="hl opt">);</span>
<span class="hl lin">   77 </span>            <span class="hl kwd">mvwprintw</span><span class="hl opt">(</span>inventory_window<span class="hl opt">,</span> i <span class="hl opt">+</span> <span class="hl num">1</span> <span class="hl opt">-</span> scroll_position<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl str">&quot;%2d %s&quot;</span><span class="hl opt">,</span> inv<span class="hl opt">-&gt;</span>item_list<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span>count<span class="hl opt">,</span> inv<span class="hl opt">-&gt;</span>item_list<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span>name<span class="hl opt">);</span>
<span class="hl lin">   78 </span>            <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">==</span> cursor_position<span class="hl opt">)</span>
<span class="hl lin">   79 </span>                <span class="hl kwd">wattroff</span><span class="hl opt">(</span>inventory_window<span class="hl opt">,</span> A_STANDOUT<span class="hl opt">);</span>
<span class="hl lin">   80 </span>        <span class="hl opt">}</span>
<span class="hl lin">   81 </span>
<span class="hl lin">   82 </span>        <span class="hl kwd">update_panels</span><span class="hl opt">();</span>
<span class="hl lin">   83 </span>        <span class="hl kwd">doupdate</span><span class="hl opt">();</span>
<span class="hl lin">   84 </span>
<span class="hl lin">   85 </span>        <span class="hl kwa">switch</span><span class="hl opt">(</span><span class="hl kwd">getch</span><span class="hl opt">()) {</span>
<span class="hl lin">   86 </span>            <span class="hl kwa">case</span> <span class="hl str">&apos;q&apos;</span><span class="hl opt">:</span>
<span class="hl lin">   87 </span>                done <span class="hl opt">=</span> TRUE<span class="hl opt">;</span>
<span class="hl lin">   88 </span>                <span class="hl kwa">break</span><span class="hl opt">;</span>
<span class="hl lin">   89 </span>            <span class="hl kwa">case</span> <span class="hl str">&apos;</span><span class="hl esc">\n</span><span class="hl str">&apos;</span><span class="hl opt">:</span>
<span class="hl lin">   90 </span>                it <span class="hl opt">=</span> cursor_position<span class="hl opt">;</span>
<span class="hl lin">   91 </span>                done <span class="hl opt">=</span> TRUE<span class="hl opt">;</span>
<span class="hl lin">   92 </span>                <span class="hl kwa">break</span><span class="hl opt">;</span>
<span class="hl lin">   93 </span>            <span class="hl kwa">case</span> KEY_UP<span class="hl opt">:</span>
<span class="hl lin">   94 </span>                <span class="hl kwa">if</span><span class="hl opt">(</span>cursor_position <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">) {</span>
<span class="hl lin">   95 </span>                    cursor_position<span class="hl opt">--;</span>
<span class="hl lin">   96 </span>                    <span class="hl kwa">if</span><span class="hl opt">(</span>cursor_position <span class="hl opt">&lt;</span> scroll_position<span class="hl opt">)</span>
<span class="hl lin">   97 </span>                        scroll_position<span class="hl opt">--;</span>
<span class="hl lin">   98 </span>                <span class="hl opt">}</span>
<span class="hl lin">   99 </span>                <span class="hl kwa">break</span><span class="hl opt">;</span>
<span class="hl lin">  100 </span>            <span class="hl kwa">case</span> KEY_DOWN<span class="hl opt">:</span>
<span class="hl lin">  101 </span>                <span class="hl kwa">if</span><span class="hl opt">(</span>cursor_position <span class="hl opt">&lt;</span> inv<span class="hl opt">-&gt;</span>item_count <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">) {</span>
<span class="hl lin">  102 </span>                    cursor_position<span class="hl opt">++;</span>
<span class="hl lin">  103 </span>                    <span class="hl kwa">if</span><span class="hl opt">(</span>cursor_position <span class="hl opt">&gt;=</span> scroll_position <span class="hl opt">+</span> <span class="hl num">21</span><span class="hl opt">)</span>
<span class="hl lin">  104 </span>                        scroll_position<span class="hl opt">++;</span>
<span class="hl lin">  105 </span>                <span class="hl opt">}</span>
<span class="hl lin">  106 </span>                <span class="hl kwa">break</span><span class="hl opt">;</span>
<span class="hl lin">  107 </span>        <span class="hl opt">}</span>
<span class="hl lin">  108 </span>    <span class="hl opt">}</span>
<span class="hl lin">  109 </span>
<span class="hl lin">  110 </span>    <span class="hl kwd">del_panel</span><span class="hl opt">(</span>inventory_panel<span class="hl opt">);</span>
<span class="hl lin">  111 </span>    <span class="hl kwd">delwin</span><span class="hl opt">(</span>inventory_window<span class="hl opt">);</span>
<span class="hl lin">  112 </span>
<span class="hl lin">  113 </span>    <span class="hl kwa">return</span> it<span class="hl opt">;</span>
<span class="hl lin">  114 </span><span class="hl opt">}</span>
</pre>

        <h3>Item Effects</h3>
        <p>
            Now, we've got almost all of the elements we need.
            We can create items, and place them on tiles.
            We have an item picker, for grabbing items and selecting them in the inventory.
            The last piece of the puzzle is making the items work.
            As I already mentioned, we'll mostly be glossing over this part with a simple example, and you cn expand it as you need.
            The general idea of getting items to do things is simply giving them basic callbacks to work with.
            This would be a pretty good opportunity for more data-driven files/scripting, but since we can't do that we'll use good old fashioned function pointers.
            The format for callbacks that I personally like is this:
        </p>
<pre class="hl">
<span class="hl lin">   15 </span><span class="hl kwc">typedef</span> <span class="hl kwb">uint8_t</span> <span class="hl opt">(*</span>item_callback<span class="hl opt">)(</span>item<span class="hl opt">*</span> i<span class="hl opt">,</span> actor<span class="hl opt">*</span> target<span class="hl opt">);</span>
</pre>
        <p>
            This function takes in an item, a target to potentially apply an effect to, and returns whether or not to remove the item from its container.
            This format works for about 90% of cases, since there's typically only one target involved.
            Things get a little bit weird in a few edge cases (such as striking an enemy with an item), but otherwise this format can cover a number of interactions.
            Now that we've defined a function to work with, let's actually put it to use.
            For this example, I'll be giving items two callbacks: One for being used, and one for being stepped on.
            We'll also give inventories a new function:
        </p>
<pre class="hl">
<span class="hl lin">   42 </span><span class="hl kwb">void</span> <span class="hl kwd">item_run_callback</span><span class="hl opt">(</span>inventory<span class="hl opt">*</span> inv<span class="hl opt">,</span> <span class="hl kwb">uint16_t</span> index<span class="hl opt">,</span> actor<span class="hl opt">*</span> a<span class="hl opt">,</span> item_callback c<span class="hl opt">) {</span>
<span class="hl lin">   43 </span>    <span class="hl kwa">if</span><span class="hl opt">(</span>inv<span class="hl opt">-&gt;</span>item_count <span class="hl opt">&gt;</span> index <span class="hl opt">&amp;&amp;</span> c <span class="hl opt">!=</span> NULL<span class="hl opt">) {</span>
<span class="hl lin">   44 </span>        <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwd">c</span><span class="hl opt">(</span>inv<span class="hl opt">-&gt;</span>item_list<span class="hl opt">[</span>index<span class="hl opt">],</span> a<span class="hl opt">)) {</span>
<span class="hl lin">   45 </span>            <span class="hl kwd">take_item</span><span class="hl opt">(</span>inv<span class="hl opt">,</span> index<span class="hl opt">);</span>
<span class="hl lin">   46 </span>        <span class="hl opt">}</span>
<span class="hl lin">   47 </span>    <span class="hl opt">}</span>
<span class="hl lin">   48 </span><span class="hl opt">}</span>
</pre>
        <p>
            Simple, right?
            That simplicity hides some nice tricks, however.
            This little setup lets us do a variety of things, such as:
        </p>
        <ul>
            <li>Applying some effect to the actor</li>
            <li>Applying some effect to the item itself</li>
            <li>Deleting the item. As long as we return true, the invalid pointer will be removed from the inventory, making this perfect for consumables.</li>
            <li>Transfering an item to the actor's inventory. Much like deletion, the original pointer will be cleaned up with a true value.</li>
        </ul>
        <p>
            For any other use cases, we can also add a user pointer to our callback as a catch-all means of providing data.
            Now, let's make those callbacks work.
            The use callback is quite simple, since we already need a way to pull up the player's inventory panel.
            All we do is map the panel function to a key, take the item that's returned, and call the new callback function with it.
            For the step callback, we're going to need to add some extra actor code.
            Back in part 3, we had our movement code in the input handling part of the game.
            At this point, it makes sense to move it into its own function, where we can also call step callbacks on items:
        </p>
<pre class="hl">
<span class="hl lin">   41 </span><span class="hl kwb">uint8_t</span> <span class="hl kwd">actor_try_move</span><span class="hl opt">(</span>actor<span class="hl opt">*</span> a<span class="hl opt">,</span> map<span class="hl opt">*</span> m<span class="hl opt">,</span> point offset<span class="hl opt">) {</span>
<span class="hl lin">   42 </span>    tile<span class="hl opt">*</span> t <span class="hl opt">=</span> <span class="hl kwd">get_tile</span><span class="hl opt">(</span>m<span class="hl opt">,</span> <span class="hl kwd">point_add</span><span class="hl opt">(</span>a<span class="hl opt">-&gt;</span>position<span class="hl opt">,</span> offset<span class="hl opt">));</span>
<span class="hl lin">   43 </span>    <span class="hl kwa">if</span><span class="hl opt">(</span>t <span class="hl opt">!=</span> NULL <span class="hl opt">&amp;&amp; !</span>t<span class="hl opt">-&gt;</span>solid<span class="hl opt">) {</span>
<span class="hl lin">   44 </span>        a<span class="hl opt">-&gt;</span>position <span class="hl opt">=</span> <span class="hl kwd">point_add</span><span class="hl opt">(</span>a<span class="hl opt">-&gt;</span>position<span class="hl opt">,</span> offset<span class="hl opt">);</span>
<span class="hl lin">   45 </span>        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">uint16_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> t<span class="hl opt">-&gt;</span>inv<span class="hl opt">.</span>item_count<span class="hl opt">; ++</span>i<span class="hl opt">) {</span>
<span class="hl lin">   46 </span>            <span class="hl kwd">item_run_callback</span><span class="hl opt">(&amp;(</span>t<span class="hl opt">-&gt;</span>inv<span class="hl opt">),</span> i<span class="hl opt">,</span> a<span class="hl opt">,</span> t<span class="hl opt">-&gt;</span>inv<span class="hl opt">.</span>item_list<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span>on_step<span class="hl opt">);</span>
<span class="hl lin">   47 </span>        <span class="hl opt">}</span>
<span class="hl lin">   48 </span>
<span class="hl lin">   49 </span>        <span class="hl kwa">return</span> TRUE<span class="hl opt">;</span>
<span class="hl lin">   50 </span>    <span class="hl opt">}</span>
<span class="hl lin">   51 </span>
<span class="hl lin">   52 </span>    <span class="hl kwa">return</span> FALSE<span class="hl opt">;</span>
<span class="hl lin">   53 </span><span class="hl opt">}</span>
</pre>
        <p>
            And now, we have a working item system.
        </p>

        <h2>A Message Log</h2>
        <p>
            This is starting to get long, but we've almost finished the entire UI.
            The only remaining part is a message log.
            Message logs are helpful for a variety of reasons.
            Not only do they give the player a way to review what happened recently, they also give concrete feedback for their actions.
            In a game that wasn't text-based, you might be able to use a compination of animations and audio cues, but here text is our primary medium for communication.
            Thus, a message log is highly important for conveying events to the player.
            If you look at the screenshot of <i>To The West</i> above, you'll spot a long rectangle underneath the map.
            That's where the log will go.
            However...
        </p>

        <h3>How Does It Fit?</h3>
        <p>
            If you've been following along at home with anything similar to what I've been using, you'll probably be running very low on space right around now.
            Unlike ncurses, or other variants that run in a terminal, pdcurses (in some modes) manages its own window, which starts out pretty small.
            Thankfully, the developers gave us a way to make the window match the size that we want, using environment variables.
            For the uninitiated, environment variables are variables that are provided by, well, the environment.
            This usually means the shell that launched your program.
            The &lt;stdlib.h&gt; header gives us a functiopn called <b>putenv(str)</b> that we can use to set these variables.
            To resize your pdcurses window, you can simply add a couple of lines like this before your <b>initscr()</b> call:
        </p>
<pre class="hl">
<span class="hl lin">   32 </span>    <span class="hl kwd">putenv</span><span class="hl opt">(</span><span class="hl str">&quot;PDC_COLS=80&quot;</span><span class="hl opt">);</span>
<span class="hl lin">   33 </span>    <span class="hl kwd">putenv</span><span class="hl opt">(</span><span class="hl str">&quot;PDC_LINES=30&quot;</span><span class="hl opt">);</span>
</pre>
        <p>
            Perfect.
            Now, back to the log.
        </p>

        <h3>Writing Entries</h3>
        <p>
            I'm not going to bore you with the details of creating and destroying the log.
            We've done this with other windows a few times now, so I'm sure you've already gotten the hang of it.
            Likewise, the actual entries themselves are just an array of <b>char*</b>s, which you can handle as well.
            Instead, I'm going to discuss the actual process of writing messages to the log.
        </p>
        <p>
            At first adding messages might seem easy: Just take a string and toss it on the pile.
            If you actually do that, however, you'll soon realize that there's more to this than meets the eye.
            A system like this only allows you to write a string to the log, which severly limits what you can do.
            For instance, say the player strikes a goblin.
            Not only can we not easily tell the player how much damage they did, <i>we can't even tell them that what they hit was a goblin!</i>
            For this, we'd either need to write a bunch of concatenation or formatting code for our string before delivery, which simply isn't convenient to do on a regular basis.
            Instead, we're going to make our log writing function variadic, giving us the freedom of writing printf-like messages directly to our log.
            Let's step though some code:
        </p>
<pre class="hl">
<span class="hl lin">   29 </span><span class="hl kwb">void</span> <span class="hl kwd">log_write</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> fmt<span class="hl opt">, ...) {</span>
</pre>
        <p>
            As you can see, this is a pretty straightforward variadic function.
            Indeed, it looks quite similar to the C's printf functions, and will indeed handle arguments similarly.
        </p>
<pre class="hl">
<span class="hl lin">   30 </span>    <span class="hl kwa">if</span><span class="hl opt">(</span>text<span class="hl opt">[</span><span class="hl num">99</span><span class="hl opt">] !=</span> NULL<span class="hl opt">)</span>
<span class="hl lin">   31 </span>        <span class="hl kwd">free</span><span class="hl opt">(</span>text<span class="hl opt">[</span><span class="hl num">99</span><span class="hl opt">]);</span>
<span class="hl lin">   32 </span>    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">99</span><span class="hl opt">;</span> i <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">; --</span>i<span class="hl opt">)</span>
<span class="hl lin">   33 </span>        text<span class="hl opt">[</span>i<span class="hl opt">] =</span> text<span class="hl opt">[</span>i <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">];</span>
</pre>
        <p>
            First off, we have some message log boilerplate to "scroll" the contents of the log, leaving one open space at the start for the new message.
            This scrolling is slower than it needs to be (one faster way to handle scrolling would be to move a cursor rather than shifting the contents of the list), but is written to be straightforward and easy to understand.
        </p>
<pre class="hl">
<span class="hl lin">   35 </span>    <span class="hl kwb">va_list</span> args<span class="hl opt">;</span>
<span class="hl lin">   36 </span>    <span class="hl kwd">va_start</span><span class="hl opt">(</span>args<span class="hl opt">,</span> fmt<span class="hl opt">);</span>
</pre>
        <p>
            Next, we need to get our variadic arguments.
            In this case, we only need the <b>va_list</b>, since we'll be passing it on.
            If you haven't written a variadic function before, this is a good opportunity to play around and learn.
        </p>
<pre class="hl">
<span class="hl lin">   37 </span>    <span class="hl kwb">uint16_t</span> len <span class="hl opt">=</span> <span class="hl kwd">vsnprintf</span><span class="hl opt">(</span>NULL<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> fmt<span class="hl opt">,</span> args<span class="hl opt">);</span>
<span class="hl lin">   38 </span>    <span class="hl kwd">va_end</span><span class="hl opt">(</span>args<span class="hl opt">);</span>
<span class="hl lin">   39 </span>    <span class="hl kwd">va_start</span><span class="hl opt">(</span>args<span class="hl opt">,</span> fmt<span class="hl opt">);</span>
</pre>
        <p>
            Once we have the <b>va_list</b>, we use a handy snprintf trick to get the final string length.
            Basically, the printf family of functions return the number of bytes printed.
            However, the *nprintf functions are an exception: They print out the length of the result, <b>not</b> the length that they are told to output.
            This means that we can call snprintf on a null pointer, with a length of 0, and all it will do is return the final string length.
            This is a super-important trick that I use for pretty much all logging and string formatting across all of my games, because it lets you create a string without making any assumptions about the length.
        </p>
<pre class="hl">
<span class="hl lin">   40 </span>    text<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> <span class="hl kwd">calloc</span><span class="hl opt">(</span>len <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">));</span>
<span class="hl lin">   41 </span>    <span class="hl kwd">vsnprintf</span><span class="hl opt">(</span>text<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">],</span> len <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">,</span> fmt<span class="hl opt">,</span> args<span class="hl opt">);</span>
<span class="hl lin">   42 </span>    <span class="hl kwd">va_end</span><span class="hl opt">(</span>args<span class="hl opt">);</span>
<span class="hl lin">   43 </span><span class="hl opt">}</span>
</pre>
        <p>
            Finally, we allocate our final string and print to it.
            Note that we need to add 1 to the length that snprintf returned, because the returned length doesn't include a null terminator.
            Another thing to bear in mind is that we don't <i>need</i> to explicitly set the final char as a null terminator.
            Unlike malloc, calloc zeroes-out the memory that it creates, so our final byte is null by default.
        </p>
        <p>
            With this function complete, we now have a list of logged strings, and writing log entries to the window is as simple as calling mvwaddstr a few times.
            I recommend taking a few minutes to add logging calls for the player's less visible actions, such as stepping on, picking up, and using items.
            Once that's done, you'll have a fully functioning UI and item system in your game.
            Next time, we'll continue to flesh out the mechanics by adding some monsters!
        </p>

        <h2>Next Steps</h2>
        <ol>
            <li>One thing that you'll undoubtedly notice about the log is that long messages wrap horribly. The wrapped lines will go right over the border, and wrap around over the next line down. This is nasty, so you may want to try adding some form of word-wrap.</li>
            <li>Once the lines wrap nicely, you may also want to be able to specify a particular color for log entries. That way, important messages can be highlighted for the player.</li>
            <li>Lastly, see if you can add scrolling to the log like we did the inventory. This may be trickier, however, because you'll want to take the word-wrap into account. Good luck!</li>
        </ol>

        <h2>Code</h2>
        <p>To download the code as of this part, <a href="https://github.com/Df458/Dark-Lands/archive/0ff185ca8b2dfde085387b15ca05e5d8d217a1c9.zip">click here</a>.</p>

        <div class="tnav-flex">
            <a href="roguelike_05.html" rel="prev">Previous Part</a>
            <a href="roguelike_index.html">Index</a>
            <a href="#" rel="next" class="tnav-spacer" aria-hidden="true">Next Part</a>
            <!-- <a href="roguelike_07.html" rel="next">Next Part</a> -->
        </div>
    </main>
    </body>
</html>
